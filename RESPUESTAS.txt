Parte I

1. Con el analisis del funcionamiento del código, podemos ver que la clase responsable del uso de CPU es "Producer", ya
que lleva a cabo más procesos (generar un número aleatorio, sumar este número a una variable, añadir a una cola, etc) que
la clase "Consumer", quien solo consulta a una cola y extrae un elemento de esta. (Imagenes del consumo mostrado en
VisualVM en el informe de laboratorio)

2. Para mejorar el rendimiento de la CPU, nos dimos cuenta de que el consumidor siempre debia esperar a que hubiera
elementos dentro de la pila del productor, por lo que planteamos un wait en esta clase con la pila como objeto lock y
un notifyAll una vez que el consumidor haya colocado algún elemento dentro de esta cola.

3. Para hacer que el productor sea lento y el consumidor rapido, esta vez se duerme el consumidor por un segundo cada vez
que consume y ahora el productor no duerme después de agregar un producto a la cola. Para respetar los límites planteamos
un wait cuando se cumple que la longitud de la cola es mayor al stock que es el límite y un notifyAll después de que se
quite un elemento de esta cola en la clase productor.

Parte II

2. El total de la sumatoria de todos los puntos de vida deberia ser N*DEFAULT_IMMORTAL_HEALTH.

3. Cuando se ejecuta el juego y se hace click en el boton de "pause and check", se encuentran datos como las vidas
   de cada inmortal que aún sigue con vida en el juego junto con la sumatoria de los valores de salud de todos los N inmortales
   vivos en ese momento. Cuando hacemos click en el boton, el juego no se detiene y el invariante no se cumple sino que
   este aumenta cada vez que se oprime.

5. El invariante de nuevo no se cumple aunque los botones de "pause and check" y "resume" funcionen.

6. Condiciones de carrera posibles:
    a. Dos inmortales atacan al mismo tiempo a otro y suman valores no correspondientes a la salud de cada uno.
    b. Dos inmortales atacan al mismo tiempo a otro y a este se le resta un valor de salud incorrecto.
    c. Un inmortal ataca, pero al mismo tiempo este es atacado y si tiene un valor pequeño de salud puede morir si
    primero resta su valor de salud en vez de sumar el valor obtenido por el ataque.